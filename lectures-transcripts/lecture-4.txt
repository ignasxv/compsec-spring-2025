UNKNOWN
They want. Don't worry. It's. What? I said this. Morning. I really. Talking to the chair. You. Are. The slowest. Yeah. All right. So you want to have IntelliJ up and running? Because we're going to work off of that example that we left off on Thursday. Java cryptography example. All right, but. Try to hit this. Okay. Mm mm mm mm mm mm mm mm mm. Ah. Okay. All right. So I think yeah that's where we were. All right. All right. If you give me a thumbs up in the back, if you can see that. Is that large enough? You need a little bigger. Got thumbs up. I feel like we're doing a eye exam here. Okay. Um, where we left off at, I believe, uh, is we were able to encrypt the message. Right? We're able to encrypt a message. And so if I run this, uh, it's asking me for a key. And there was a caveat here. Does anybody remember what the caveat was? Anybody tell me. Something. But something. But. Yeah. Right. Know what the caveat was not what is the caveat. Yeah. It had to be a certain length of characters. Right. Because we're using a yes. And what are the valid key sizes? Are in 28 256. And in between 192. Right. 192. So, um, if we counted out the number of characters. So if we just take 16 times eight, right, that gets us to 128. That gets us to the minimum. So we would need 16 characters. So uh, and again, like I said, we're going to take a look at an approved way of doing this. But if I type in case Western Reserve like that, I think that's 16 characters. And that would work as a key. Otherwise, if I take off that R and I go ahead and I try to encrypt some message like hello, I get an exception that gets thrown invalid as key length is 15 bytes, it needs to be at least 16, right? So 16 characters. Um, so if I run that again and I do the Case Western Reserve, I Her Case Western Reserve like that. I can then do I can then encrypt a message, type in hello. And then I would actually be able to get something out of that. Right. All right. Now, I know we're beating this pretty hard, but, um, what do we know about this? What's the telltale sign of it? Base64 encoded. Right. How do you know? Yeah, it's got the padding on. Yeah, we'll always have that if it's for encoding. No. Well, not right. Okay. All right. So that shows us I'm actually going to copy that. That shows us that we can actually, uh, encrypt something. But we didn't get to the decrypt part. Right. Um, so let's jump over. Let's jump to that piece. And I think I posted this example on canvas. So if you want to work on that you can grab that example on canvas. I'll also post this one at the end too. Okay. All right. So I'm going to copy that. Copy the encrypted message. And we filled out the encryption piece. Now we got to fill out the decryption piece. So if we think about decryption, all that we're really doing is work in reverse, right? Um, I'm going to ask for the message to decrypt. And just like before, where I got it from the scanner, I'm going to do the same thing here. Right. So I'm going to get the message that they want to decrypt. And I'm going to initialize my cipher just like before. But it's not going to be encrypt mode. It's going to be decrypt mode. Right. And I'm going to give it the key. And that key I get outside my F right I'm getting that up here. So I'm going to give it the key here. And what's the first thing we need to do. Yeah. What's that? A wide array of storage data. We could do that, but we're jumping. We're skipping a step. We're not going to decrypt it yet. We need to. Know the basics before the coded message. Put it into a string. That's right. We need to decode it. We need to decode it. That's exactly right. So just kind of works in the reverse order. Right. So first thing we want to do is we want to, uh, we are going to create that byte array. Right. And this is still going to be my encrypted data. And I'm going to call my base64 encoder and get a decoder to then decode that string. Right. So notice that this is overloaded. So I can pass to it either a byte array or a string. We have this ring here, so I'm going to pass that to it. At this point now I should have some, um, that encrypted data is now base64 decoded. Now I have bytes. Now that's perfect because I need to use bytes. I need to pass some bytes to decrypt. Uh, so now if I want to get that decrypted data again, that's just going to go to a byte array. And I'm going to call the same thing that I kind of did before. When I did encrypt I'm going to do cipher do final. And again notice that this is overloaded, right? A bunch of different ways to call it. But I'm going to use this method up here where I pass in the byte array. At this point I should have decrypted bytes in Java. Can we create a string from bytes? Yes we can write. So I'm going to create that decrypted message. Set it equal to a new string. And again if you take a look at the constructor that is overloaded it's looking for a byte array here which we have here. I'm going to pass in that decrypted data. And I'm going to print out that message. Oh not message. Decrypted message right. Hopefully that message is still saved in my clipboard. But again we're just working in reverse when we're doing decryption. So encryption we first encrypt the message with base64 encoded if we need to have it represented as text. So let's imagine that you're calling a web service, or you're storing it where it needs to be, maybe in a comma delimited file or whatever it may be, right? Stored in a text using base64 encode. And then when we get ready to decrypt that message, we have to basically decode it first. Then we could decrypt it and then we are all set. We're all good to go. So now if we run our program. Enter the key case Western Reserve or Novi and hit enter. Now I'm going to decrypt. Hopefully it's still on my clipboard. Yes it is. So that would be the 64 encoded encrypted message. And there it is. Message is hello. Okay. Now I can tell you that this works, but let's make sure that what happens when we enter an invalid key. So I'm going to do a different key. Uh, Case Western Reserve Reserve I'm going to do a capital R, right. Just a subtle difference. Right. This should not work. I'm going to decrypt that. Paste it in there and I get an exception thrown. Bad padding exception. We could catch that. We could let the user know that they entered the wrong key. All right. Any questions on this example? Yeah. All right. Fairly easy to use this example to create a very basic but not really secure. So a pseudo secure encryption decryption program okay. We're going to take a look at how we can improve it. Uh, today. Um, any questions on this, though? I will post this at the end of class. No. Okay. So that's basically how we can do some basic encryption. Uh, decryption. Um, I want to dive a little bit more into, uh, cryptography today and take a look at a better way of a way of improving this, and then also take a look at, um, how we can, um, or how cryptography is applied to certificates. So. All right, so let's just do a quick review. Um, we talked about this last week. How is a hash different from symmetric and asymmetric encryption came by Tommy. Yeah. Yeah. One way. Right. One way. So, um, we can't we don't use a key. Uh, we can't decrypt it. We can attack it, though, right? But we can't decrypt it. How can a hash be used for integrity? Wait. Tell me. Yeah, yeah, we can make a signature out of it. Right. So if I have a document, I generate a hash from it. Uh, somebody can verify that that document wasn't modified by computing the same hash. Right. And we say it with software. Good. Good. How can a hash be used for confidentiality? Remember, CIA is our compass. How can it be used for confidentiality? Yeah. Star Wars and all that stuff. Perfect. Perfect. Storing passwords in a hash form. Not in a plain text form. Um, if you do forgot password and a company emails you your password, what should you do? Yeah. Stop using them. Right. Uh, because that means they're storing your password in the clear, right? So we can ensure a confidentiality, uh, by hashing that password. So, um. All right, so we talked about this, right? We should store it in the database so we can, uh, email it to them. That's false. Right. We shouldn't do that. Uh, which hash function is stronger? Which of the two? Sha256 should we use MD5? No. All right. What's the issue with the key in our Java example. What was the issue again I know we already talked about this but what was the issue. What is it. Yeah I mean it needs to be a certain length right. Needs to be a certain length. So. All right. So what I want you to do is, uh, I don't include the URL because I want you to actually look it up. There's an organization called OWASp org. We're going to take a look at it later. What I want you to do really quick. Just spend a few minutes on this with somebody next to you. I want you to find the following cheat sheet and clue the URL in there. But if you just do a DuckDuckGo search Avast Password Storage Cheat sheet, I want you to find answers to the following questions. What does assault protect against? We haven't talked about that. How is the salt different from a pepper? This isn't a cooking class. These are real terms okay. And which of the following are acceptable ways of storing a password. So get into groups, pair up, do a search, look through it, come up with answers to those questions and we'll talk about. Those. Okay. Working groups talk with one another in that network. We talk about social isolation is This is just as bad for you as smoking, so it's good to talk to one another. Introduce yourself. Share your social skills and build those up. So like I said, we will be going back to all of us throughout the semester. So you might want to look at my website. So. This is. The official Twitter. Account or not. Yeah. So. I'm sorry. Thank you. Ma'am. All right. Can a group tell me what a salt is? And what does it protect against? Yeah. Misdemeanor. Hash with a separate piece of information so that they don't ask for cash or. Perfect, perfect, perfect. So it protects against the rainbow table attack. We will talk about what that is, but just add some randomness for individual entry. Right. All right. What about pepper? Somebody come in with a pepper. How many pepper. Yeah. There's a little thing stored separately that allows you basically it's another you take the password hash and you hash it again with a key. And that key is the pepper or the pepper somewhere far, far away. So the pepper applies to the whole table. Yes. As far as zip codes. Yes. Right. The interview I'm not sure if they have salt individually per row. Okay. Peppers the whole thing. All right. So just another degree of randomness, right? Um, which of following are acceptable ways of scoring a pass with regard to ID? Yay! Nay. Gay? Yeah. Anybody see Gladiator? Hey! Come on. Anybody see my own one? I like swagger. Just a few. Just 3 or 4 people. You guys got to see Gladiator. Gladiator two? Just a thumbs down and a thumbs up. All right, so our guy two. I just never looked at me like, what is he talking about? Don't worry, that won't be on the test. All right, give me a thumbs up. I got two ID. Is that acceptable? Yeah. Good, good. Uh abcdef. Two. Acceptable. Good. Mm. Five. Ah! Man. Give me thumbs down. Yeah. No MD5. We don't want to use that. Okay. Um. What is that? Oh, okay. I'm like this. Somebody's got a weed whacker running right now. It's. It's cold out there. All right, um, so we don't want to use MD5, so, uh, it's part of the answer to assault was to protect against a rainbow table attack. So if we don't, if we don't use a salt. If we don't use a pepper. If I were to hash using Sha256 or 512, whatever it may be, if I were to hash some common passwords, and every year there's different organizations that come out here, the most common passwords that people use. What I can do is I can run, um, rainbow table attack against a database that I get that has a password hash, but no salt, no pepper on it, and figure out what those passwords are. Because if I take hello or password or pass 123, four, um, and I were to run it through a hash algorithm, I can compare the hash I compute with what I find in the database and be able to attack, um, that hash password by being able to figure out what it is. So, um, but using assault, using good password policies to not allow somebody to use password, uh, to not to allow people to just use just. Just characters by themselves or short passwords helps protect against that type of attack. Okay. Now, we may talk later in the semester about password policies. Oh, there's a typo up there. Um, you guys probably run into this. You go to set a password, and there's some really ornery policies out there. You have to use this and that and blah, blah, blah. Um, there's some new guidance, uh, from it might be the NSA. I'm not sure. Uh, but pretty much saying let people have long passwords. You shouldn't cut them off. Um, because the longer the password is, the harder it is to, um, to be able to attack. So. All right. So we said Abcdef two is a better strategy. Uh, and so what I want to do is take a look at how we can actually, um, use that in our example. So what we don't want is we don't want the person to actually have to type in the key, okay? We don't want them to create the key manually by typing in a message. So, um, so instead of just creating that key from just a string, we're going to use Abcdef two to generate the key which is much stronger. So the first thing that we need to actually do though is we need to generate a salt. So I'm going to do this right at the beginning here before we do anything else. And what I'm going to do is I'm going to use a secure random number generator. So you've probably done this in programing where you generate a random number. But if you don't use a secure random number generator, sometimes that random number generator can be predicted. And so you want to make sure that you use a secure random number generator and that obvious cheat sheet that you looked up that will actually have some guidelines on secure random number generation, and you probably want to bookmark that anyways, because if you want to keep keep updated to what the latest and greatest is or the best advice, you probably want to reference that. All right. So let's go ahead and create a secure random number generator. And I'm going to do new secure random. And this is going to be our salt okay. So I'm going to generate a salt using this. And to store that salt is I'm going to create a byte array. Called salt I'm going to make a 16 bytes okay. Now I have no idea what's going to be generated here. And that's the idea. So I'm going to do random dot next bytes. So I'm going to store that and to solve some, use that random number generator to store the next random bytes into that salt. Now how can I quickly verify that this indeed works before converting to a string? What can I use? I can litter my code with system.out.print statements, or I could use something else that's more flexible, more powerful. That's right. Yeah, I was looking for it at 345 alum. I can use the debugger. Right. Use the debugger in there. So I'm going to set a breakpoint. Actually I'll set a breakpoint right here too, because at this point it's not going to be populated. I'm going to hit the little bedbug symbol there. It looks like a bed bug. Oh, by the way, I'm totally separate, but I think it's Disney. If you have Disney Plus, I think it's Disney Plus. They have A Bug's Life with narrated by Aquafina. But watching with the kids is really cool. So, um, they had this bug spraying, this acid mix on these ants they're trying to attack, and I'm like, man, that's some serious defense there. All right, um, so there's our salt. Our salt byte array is empty or not empty, but it just has zeros. But as soon as I step over that breakpoint, you're going to see this populated with some data. Okay. So I'm going to step over to that and boom there it is. Right. There's some random numbers there. Okay. So that's my salt. Now we need to store the salt somewhere. So if I want to store it what do I need to do. If I want to store this as a string what do I need to do? Oh, you guys are breaking my heart. If I need to store something that's encrypted, I need to. So you are base64 encoded right. All right. So I'm going to create a string called salt string. And I'm going to base 64 get encoder. And now my code to string right that byte array. Okay. So I'm going to code to string that byte array. And I'm going to feed to it my salt. And at this point I should have a salt represented in a string. And I'm going to run the debugger again. I hit that and boom there it is. Right. And we know it's base64 encoded. Or one way to tell. Right. I want you guys to always think that anytime you see an equal sign at the end of a string that's base64 encoded, it's not a hard role. It's just a hint. But here we can see that it is encoded. Okay. All right. Any questions on that piece so far. It might be one. Alright, so what are we going to do with this salt? All right. So, um, ideally what we would do is we would store that salt somewhere. Okay. But what we're going to do is we're going to store it in code. Storing it in code is a big no no. But we're doing it just for, uh, practice. So once you have that salt string generated, you can actually copy it right from here. You do copy value. And even though I generate it here, I'm going to comment out that code. And I'm going to store it right here. All right. But ideally this would be stored in like a file um salt string. And not in code. And the reason why I don't store this in code is very easy. One is you can quickly discover it, um, using either some sort of hex, uh, so some they'll be able to read the hex from the code. Uh strings command uh or string program within Linux or Unix, uh or decompiler. Okay. Either way you'd be able to quickly find out what that string is. So, uh, but we're just going to do this, uh, just to, uh, just to verify that it works. And when I what I'm going to do next is I want to verify that I can convert that string back to the original form. So take a look at your salt if you used the debugger. And I'm just going to remember 101 and then -115. I want to make sure that I can convert it back to that byte array. Okay. So if I want to convert that salt string back to this, what's the first thing I need to do. What do I need to do first. What format is this in base 64? So what do I need to do. Decode it. That's right. Okay so so here I got that salt string there. First thing I need to do is I need to decode it. So I'm going to do a base. I'm going to do a string. Sorry salt. Some override that salt that I have up here. I'm going to set that equal to base 64 get decoder dot decode. And I'm going to feed to it that salt string salt string dot get bytes. All right. So let's remember and yours might be yours will should be different. If it doesn't then this isn't a secure random number generator. But if I take a look I got 101 -115 100. I'm now going to use that consistent salt string that I created here. So I'm going to run this through debugger again I should have 101 -115 I'm going to stop and rerun. There it is. 101 -115. So I successfully converted that base64 encoded salt back into its original form. Not encrypted just encoded. Okay. All right. Any questions so far? No. All right. Now we don't want this person typing in a key. Big no no. All right. What we want to do is we want to generate that key. So what we're going to do is we're going to create a pb CDF two key. So I'm going to add a new line below here. And I'm going to create a new key spec. And I'm going to set that equal to PB e key spec. And I'm going to take my key string. Oh wait. Hold on. Did that a little bit too early. Um I'm going to put this right above it. Now, this actually isn't going to be a key, but it's going to be more like a password. Okay. So Abcdef is password based derivation key function two. It requires a password. Okay. Um, for those of you that use a. Well, I hope all of you use a passcode on your phone, but it functions the same way. Your passcode serves as a way of generating that key so you can unlock your device. All right. So the first thing that we need to specify here is when we take a look at the method signature of that constructor. Come on pop pop pop pop. That's not popping up QB PB there it is. That's where it's not showing me the constructor. All right, well, anyways, we'll go with it. Um, so I'm going to actually let me dive into this. So if I take a look at that At PBE spec, you'll notice the constructor can take several arguments. So here. I noticed that. All right. It takes, uh, and just what I did is I held down command and I clicked on the actual class name, uh, to be able to dive into the documentation. It takes a password, which we're going to give it. It takes a salt, which we're going to give it. It takes an iteration account which we're going to give it. And it takes a key length which we're going to give it as well. Okay. So um, the first thing I'm going to do is I'm going to give it that key string, I'm going to convert it to a character array. Right. So that's the uh, password that I typed in right here. It's then going to require salt. Well we got the salt generated. It's going to ask me how many times do I want to run this to generate the key. Now this number that you feed it has to be consistent. So you come up with the same key each time. Um, so if you take a look at that cheat sheet. I think 1024 is suitable. It might be on the lower end, but this is how many iterations you're going to run. And then the last thing is going to ask is for a key size. So I'm just going to do 128 just to kind of keep it simple. If I take a look at this oh that's why that's why it wasn't popping up. The problem is I go from this class to iPhone app development and I do some code. And Kotlin doesn't require the new keyword. So um, so sometimes I've been omitting it in these Java examples. So anyways. Um, so here we create it. And once we create that we want to use a factory to actually generate that key. So I'm going to create a secret key factory. And if you've taken a look at design patterns, you'll notice that the factory pattern is one of the common type of patterns that you can use. And I'm going to get an instance now here this really you have to be really careful with this. So um we're going to do pb CDF two. All right. That's the algorithm we're going to use with H mak Sha 256. All right. So Sha 256 is going to be our hash function. We use the pb cdf two algorithm with Mac. And we're going to generate. A private key from that by column factory generate secret. And we feed it the spec okay. Don't worry about that red squiggly right now. So our specification is here's the password we're going to use. There's this random salt that we're going to use. We need to keep track of that salt. Because if that salt changes every time. We're not going to get the same key. The number of iterations. The key size. We then specify the algorithm we're going to use to generate that key, and then we generate it. If I can spell private right. All right. When we look at this though what's the issue with that generate secret. What's the issue. Yeah. Yeah. It's it says hey there's an exception here. What if that key spec that you specified is invalid? I know I've been teaching you guys bad practice, but what are we going to do with that exception? Throw it right. Just throw it off. So I'm just going to take the lazy approach again. In industry though, you want to catch these. So I'm just going to add that exception to my method signature. And now I'm just throwing everything right. I'm throwing everything out of here. Right. But we should catch those and handle those errors more gracefully than crashing a program. All right, so I put 1024 in here. You tell me. Look at that Olaf's cheat sheet. Is that a suitable number? For generating a key. You tell me. Because if you're doing a code review and somebody want to write that in code, you should know where you can look to point out if there's an issue with that. Is that suitable? Yeah. So 600,000, 600,000 for some reason. Yeah. So we should use a higher number there. But let me just do this really quick. Um, here's where we generate that secret. I'm going to set a breakpoint here, and I'm going to run it through a debugger. And my machine is fairly fast. Right. It's not it's not like I got like a laptop from the 90s or something like that. Uh, but I'm going to type in a password here. I'm going to set a breakpoint there. I'm going to step over. I'm going to step over. And here I'm going to generate the secret I'm going to step over. Notice the pause. Not that big but that's 1024. Let's increase the 600,000. That's the problem. Yeah I kept it small here just because we're testing. But I do want you to be aware because if you said, you know what? Like like you go to implement this code at some company and they're like, who taught you that? It was 1024. They're out of their mind. I just want you to do it for. For testing. So now generate that private key. Now, it's taken some time. Right. Because there's 600,000 iterations. And I don't think that's. Why I'm going to make a cup of coffee. You guys let me know. Come on. I need my battery later for the next class. It will stop, right? So how much should we use? 600,000. All right, so keep in mind. Right. Um, when you think about devices that may use this, they have specialized hardware for this. Right. So that does improve things. So, uh, more. Yeah, more and more when you're taking a look at, you know, machines that are built, um, they'll have not just, um, chips specialized for encryption. They'll also have chips specialized for neural networks now. Right. Uh, to speed things up, um, at some point, I'm going to get impatient here and just stop this, but, um, but, yeah, you should follow the recommendation. There's specialized hardware for it. Um, when I worked at, uh, key, I did work with, uh, some of the infrastructure that was managed for keeping, uh, the keys, and there was specialized hardware just for generating those keys and doing encryption decryption. So I was going to say, if it took this long for the last time for the website to compare your password to the hash, uh, yeah, they would have users. Oh, it'd be crazy, right? It'd be crazy. Now, I do want to point out, though, that is different from just generating a hash. This is generating a this is generating a key for encryption. Right. So we wouldn't follow this. We won't follow these steps for storing a hash in a database. Okay. So it is a little different. This will actually give you a key that you can do encryption and decryption with. Um all right. I'm going to stop this though. Uh, but anyway, so that's why we're going to stick with 1024, because you will use this for your assignment that you'll get Thursday. Um, which is a coding assignment. But anyway, so, um, so we'll leave it at that. And then now, now that I have a key, a private key, I can use that for encrypting or decrypting a message. And this is much better because now I'm not relying on the person to provide a password. Um, that is going to be, um, uh, that's going to be, uh, a specific length. Now, we could just use, uh, that key to do our encryption. So now here I ask them, do I want. Do you want to encrypt or decrypt? They still give us the option. I specify the cipher, but now what I can use is instead of this key that I generate here from a string, I can generate from that private key and call get encoded, and that will get the bytes from the key that I now generate that I'm generating using a a number of iterations and any length password. So. I'm going to go ahead and run this through the debugger. Or actually I'm just going to play it just to make sure it works. And so my password I don't use it for my Wi-Fi but I'll show it up here. My Wi-Fi password is really long. And I also make my Wi-Fi password really long because my kids friends don't want to type in a long password, they just give up. And so it keeps them off my network, which is even better. But my password used to be Sophie chases Luke and Emma around town. That was my password. Okay, now I can share it with you because it's no longer that password. But Sophie was my dog, and Luke and Emma are my kids, and now I can have a really long password. And if I want to encrypt something and I want to say hello. There's a message base64 encoded. I can copy that. And now I'm going to decrypt it. Someone say Sophie chases Luke and Emma around town. I might decrypt the message. I'm going to paste that in there. Uh oh. No. No. Oh, I gotta run it again. I messed up. I thought I had on my clipboard. All right, so I'm going to keep the password just small this time. Um I'm just going to say CW crew. All right I'm going to encrypt. I'm going to say hello. There's my message. But notice doesn't matter the length now, right. Much better. I'm going to run it again. CW crew. I'm going to decrypt and I'm going to paste that in there again. And now we get hello. Right. Doesn't matter how long the password is. Um, although I will advise if you are using Abcdef two, you should advise a person to have a minimum length of the password. Um, but now we can just use that as a matter of the length. Much stronger form of encryption and decryption. All right. Any questions? On this example I will post it on canvas. All right. So just do a quick recap. Salt provides randomness that we need on there. We specify uh, the iteration count 1024, we specify the key size. Much better way of generating key. You will use the examples that you've seen here for your next assignment which which you will get Thursday, which is essentially creating a password manager that you will store the passwords encrypted uh, in Java. Okay. All right. So let's return back to uh, certificates. Let's talk about that. Actually, um, we've still got to talk a little bit about salts. So okay. So there's going to be another thing that you will see with encryption. It's called an IV initialization vector. Um, but uh, just to recap on salts, uh, we need those anytime we store a hash password, uh, because our Y's will be vulnerable to a rainbow table attack. Um, and they're actually stored with the hash data. Okay, so if you're wondering where you store the salt, you can actually, like, if you have a password field in the database, you can store the salt right along with the password. And that is commonly how they are stored. Okay. So it just adds a little bit of randomness to it. Okay. Um, now something that you'll also see is something called initialization vector. This just adds some randomness to symmetric encryption. Um, you also need to store those as well, because if you change that initialization vector, you will get a different outcome when you encrypt and decrypt that data. So any kind of randomness that you add to your encryption or decryption, you essentially need to remember that randomness. Otherwise you won't get the same result. Makes sense. So let me just show a quick example with this. So imagine I change my um, I'm going to run this, uh, again. Well, actually here I'll take that's my message to decrypt. Let's say a developer comes in and says, you know what? This is not strong enough. I took a class with Jane Doe. And Jane said it needs to be 2048. So what they do is they go in here on a Friday at 4 p.m., they make this change, they push it up to production. And now, uh, you know, somebody signs off and says, yes, you're right, that is stronger. We should use that, right? Uh, but the problem is we forgot to update the passwords, right? Uh, so my password was, uh, or the password is in the database, so my password is true. I'm now going to decrypt. I'm going to take that same message. Hopefully it's still there. And I get an exception because I changed the number of iterations. Right. I changed the number of iterations. So even though we stored that password using Abcdef two, we remember the salt. We remember the key size. This also matters. So any parameters that you feed into this. That key string needs to be the same. So they have to give you the same password. That salt needs to be the same. The number of iterations needs to be the same. And of course that key size needs to be the same. You change any one of those you're going to modify or you might not get. You're not going to get the same result when you try to decrypt something. Okay. So you need to remember all those. So coming back to well somewhat with the initialization vector, that has to be remembered as well. If you don't save that you're going to get a different result. And the one thing you never want to do in a company is mess with people's data. You can have, you know, an exception page or anything like that. But once people aren't able to recover their data, forget about it. It's done. So, um, so anyway, so let's take a look at how we can use salt, uh, on Linux. So let's go ahead and boot up your VM. And I know that will take a little bit of time. So if you don't have it booted up, that's okay. I'll wait a little bit. Because we don't need to use, uh, a Java program to, uh, to generate a salt. You can actually look at this on Linux. Look at how we were doing hashing last time. All right. So I'll give it a little bit for you to boot up your VM. Don't forget you have a homework to win. Yeah I have a question about the audience. So Decided for the duration of the holidays. Yeah. So you would have to keep in mind that whatever was saved, what the original parameters were to that, and then you would have to run them through a migration. So if you if you're looking at some encrypted data, you would have to remember that that data that was encrypted was using 120 bit key size. Right. So you'd have to you have to store that somewhere. It could be within a database table or the user profile, whatever it may be. So the next time they log in, once they give you that password to unlock that data, you could take that to generate that 256 key. And then you have to go through re encrypting that data. Um, the way that um, if you're really interested in this, uh, Apple actually publishes, um, let me see if I pull it up. They will publish Apple Security guide. Uh, they publish a security document. Um, it's pretty interesting. Platform security. And one of the things that although this is much more expansive now. Um, yeah. So they got a whole document about how they do encryption and whatnot. Um, but if you're really interested in interested in this and how you can kind of like manage it or, you know, answers this question a little bit, uh, but they have this, uh, framework called data protection, and it's a way of managing, um, encrypted data on the device. And so generally, the way it approaches it is that when you want to change your passcode on your phone, it would be pretty intensive to have to re to encrypt every or decrypt every file and then re encrypt that. So the way that they approach is kind of this key hierarchy, where you have one key that essentially encrypts other keys that will then encrypt other keys. So each file will actually have its own generated key. But that key is then encrypted if you follow it all the way up based on your passcode. So, um, so it's kind of a way of keeping that. Um. Oh, yeah. I'm not making that. Um, it's kind of a way of keeping it a little bit less resource intensive. So to answer the question. It would only be updated after that. Yeah. Yeah. Because you need that. Because otherwise you can't re encrypt the data. Yeah. And then you have to remember all the parameters that were used to generate that key. Good question. Um, that's a tricky problem. Uh, a tricky thing to do. Just as if anybody's taken a database class. If you write like some, like web services or an application that uses a database and you have to migrate the user to a new database, that's also a new database schema. That's also a tricky problem, too. Um, there's definitely like apps and frameworks that help with that. Like Flyway is like a framework that would help with that database migration to keep track of those changes. But yeah, it's a good question. All right. Other questions. All right. Let's jump over to our VM. All right. So on the VM, um, as you can imagine, uh, when we say don't store passwords in the clear. We certainly should not do the same thing on Linux. Now, one of the things you have to do in your homework is you have to do some piping. Um, so let's go ahead and let's get some practice with that. Um, but I'm going to cat slash slash password and I'm going to pipe that and I'm going to grep for my username Brian Krupp. Now don't grep for Brian Krupp on your machine unless you create an account called Brian Krupp, which would be weird. Um, but if you go ahead and you cut that out and you take a look at that, you'll see your user account, right? And you'll see your user ID, your name, your home directory, your shell, and so on. Okay. Now way back, back, back in the day. Your password used to be stored in here. That's no longer the case. Okay. And there's good reason for that. Um, uh, Etsy password is open for anybody to read. And of course, I wouldn't want to store even a hash version of a password in a file for anybody to read. Um, but there's another file called Etsy Shadow. Now, if you run this, you're going to get womp womp. Permission denied. Right. Any normal user and I know that you're the admin, uh, on your VM should not be able to read this file. Okay. Uh, so what we're going to do is we're going to do a little cheat here. We're going to do a sudo su. So we're going to do a privilege command to switch our users. I'm going to jump over to root. I'm going to type in my password. And now I'm root I'm going to run that same command. I'm going to cat at C shadow. And there's a shorter way of doing this. But I want you to get comfortable with doing a pipe, and I'm going to prep for a brine. And when I do this, I'm going to see something a little different than my Etsy password entry. What the heck is that? What do you think that is? Any guesses? For me. That's a password answer every time I log into my VM. You all know that I just did a Sudoku. There's no way I typed that in that fast. It's a hash version of the password, right? And there's a salt in there. So, um, when we take a look at this, there's a couple of ways of breaking it down. Um, one is we have our username. We have a colon. And this flag here will talk about how it's hashed. I don't remember where the break of this is, but, uh, this is the ID, I believe, of the algorithm it's using. And I believe this part is where's where's it break off at? Um, I'm trying to remember here there should be another dollar sign. I believe this is the salt right there. That's the randomness that's added to it. And then finally we get to this piece, which is the hash password. Okay. So even on Linux we see that stored as a hash. Now I will never, never put on a quiz or an exam a string like this and say tell me which one's the salt, which one's the hash password. Okay. But I just want you to know how it's broken up, okay? And it depends on the algorithm that's being used. Uh, I think you might be able to see it in the main page, um, to see which one is being used, but that's how it's broken up. So it seems strange because, see, password doesn't have a password. It doesn't even have a hash version of it. It used to back in the day before my day. I'm not that old, but back in the day. But now it really just holds user information. And in fact, if you're really curious, you can actually open that file and you'll see a bunch of different accounts there. You're like, wait, I don't know these users. Well, root is our administrative user. Um, look, even games has their own user. But you'll see like data. That's for Apache Web server, which we'll talk about later. But you'll notice that some of these accounts have these shells called user Aspen. No login, meaning you can't log in as these users. But these processes are running need to have an account that they run as. So that's why they're here. Okay. But at the end here you'll see. Well that's interesting I didn't know open OpenVPN is on here. Interesting. Uh, but anyways, that's where you'll see my account. And my account is really the only one that could log in. Okay. All right. Any questions about the salt? The password on the in the in the, um, uh, the password file or the shadow file. No. All right, so let's jump over to, uh, certificates. So certificates kind of bring, uh, several of these things together. And, uh, they fundamentally do. And I want you to remember this. They do two main things. One is a way of sharing your public key with anybody that wants to send you a message. Okay. When you go to a website, you access that certificate. You see the public key there. All right. So it's a way of sharing that information. The other mechanism is a way of verifying they are who they say they are. And we're going to talk more about this later in the semester with authentication because authentication works the same exact way. All right. The way they say they are, who they say they are is by having somebody sign off on it that you trust. Right. If you don't trust that entity and they say that, yes, I am indeed google.com, your browser is going to throw up a warning saying I don't I don't trust this certificate. You shouldn't proceed. Okay. So, um, if you go to any website, I'm going to go to DuckDuckGo. Com actually let me pull up Firefox duckduckgo.com. And you click on that lock icon there. You're going to see that this certificate is verified by digitizer and digit cert uh is an entity that my operating system trusts okay. If I didn't trust them when I would enter DuckDuckGo, it would give me a warning. Okay. But if I click on that, it'll tell me connection's secure and it will tell me who verified it. And I can click on more information and then I will see you'll see a view certificate button here. I could take a look at that certificate. So here will tell me information about DuckDuckGo. So this may seem strange, but on certificates you can see the country, the state, the locality that they're in. And then you'll see a common name that asterisk there is a wildcard. So if I were to go to like mail DuckDuckGo, dot com or DNS, duckduckgo.com, this certificate would be valid. For this. I can see who issued this certificate. So who was signed off on. So I see it signed off by Digital Cert. How long it's valid. So this is valid until December 18th 2025. Uh by the way uh previously certificates, uh, they used to be valid for a couple of years at a time. Um, now they're valid for a year, but even the industry is moving to having certificates not be valid even a year. So issuing them, like, even every month, there's a certificate provider we might take. Take a look at it later called Let's Encrypt. That automates this process for you. So, uh, but anyway. So, um. We can then see what that public key is. So here we see 2048 is the key size. Uh, and then we got some additional information on there, like a serial number, signature algorithm and so on. Okay. So if my browser wanted to communicate with DuckDuckGo, it uses that public key. Okay. And I can pull down that certificate in a PDF file. Now what's important with this though. And I actually think Safari does a better job displaying this is that we can see who signed off on this. So this is called an intermediate cert. That intermediate signed off saying yes, this is indeed DuckDuckGo. Um, and they essentially put a stamp on their certificate saying we're going to sign off on this and they can use their private key to sign to generate that digital signature. And you can verify that they signed off of it because again, they have their public key that they advertise. Now that intermediate cert we may not trust but we may trust the root certificate. That certificate signs off on an intermediate which signs off on this certificate. So you form a chain of trust. Okay. Now you might be wondering, well, why is my operating system trust us? Where is that from? Uh, I'm not sure where you would access it on windows, but there's something called the keychain. Gotta be careful opening this. Um, but if I were to take a look at, uh. Let's see, we got digit cert. There's digit cert, there's their trusted certificate right there, and I have it installed on my operating system. That's what establishes that trust. I for some reason, Apple says that, you know, this organization we trust and, you know, so let it be. But there it is. And you'll notice it's kind of very subtle. But if I zoom in here, it's really hard to tell if this says root. The root certificate. The root certificate is unique in that it signs off on itself. When you take a look at the issuer. The issuer is the root certificate. Because there's once you hit that root, there's no farther up the chain. You can go okay. So if you install that root certificate you will trust this website. One thing we'll take a look at later in the semester is how we can install our own root certificate and then intercept traffic from a mobile application or a website. Okay. But we'll take a look at that later in the semester. So anyways that's how you can see that chain. Like I said, I think in my opinion, um, Safari does maybe a better job of showing this chain because you can kind of see it here that's issued by DuckDuckGo. Here's who signed off on it. And then here's the root certificate. Again that's an intermediate certificate authority. Okay. Now, like I said before, you have to, uh, before these are issued, you know, for a couple of years at a time. Um, now it's at a minimum or at most. It should be, uh, a full year. Uh, but they also used to cost a lot of money, too. Um, we used to pay quite a bit of money to actually get, uh, certificates, but, uh, but now you can actually use a service called Let's Encrypt, and we'll talk a little bit more about that later. Uh, but if you just do a quick search for Let's Encrypt, um, it's a free service, uh, to generate, uh, certificate, it's backed by, um, f and, uh, as long as you can prove that you are indeed your website, you can get a free certificate. In fact, on my website, it's, uh, let's encrypt, uh, that uses it so it doesn't show. Let's encrypt there. But that's the R 11 that you see there. Um, but that's how I got my certificate. Okay. From there as well. Okay. All right. But, um, but anyway, so that's a free service. So the idea is to make everything on the, on the web through an encrypted channel so that you are always talking securely. All right. So there are some specific attributes that are important uh, within the certificate. Uh, there is a standard for formatting a certificate that's x509. But within the certificate you'll see the version. So the x509 version, the public key. Because remember a certificate does two primary things. Prove they are who they say they are by have by you trusting the issuer and then sharing that public key, that serial number is just a unique ID on that certificate. The N is the actual name. So the entity that that certificate is signing off on. So for example that star.duckduckgo.com that's at the end the validity of the certificate. So if you want to really break the web on your machine, change your date to be 2026 and you'll probably see a lot of websites that aren't trusted because the certificate is not issued in that time. The digital signatures. So the CA signing off on this certificate, what algorithm they use so that you know what you should use for verifying it. And there's some other optional fields on it, um, like the locality and so on. There's a bunch of different certificate authorities we already just talked about Let's Encrypt, but assigns a common one digit cert, which you just saw, Comodo and a lot more. But there's also like I said, you can have a self-signed certificate or a private CA within an organization that you trust, and that could be a way for you to kind of issue out certificates for, like your test environment so that you don't have to generate a certificate externally each time. Because when you generate a certificate for like a hostname that you have internally, people outside may know what that hostname is and you might want to keep that as secret. So the way the certificate is issued, um, the way that you can create one is you just create a certificate of request called a CSR. You generate that and then the certificate authority will verify that you are indeed that identity. So I can't just go to Verizon and say, hey, give me a certificate for gmail.com because you're going to ask, who are you? Can you verify you're from Google? Um, so that CA will verify I am who I say I am. Um, and then um, when I generate the certificate, uh, they'll sign that with their private key, and then people can verify it with the public. Okay. Uh, and then all I have to do is just put that certificate on my web server, and then I'm up and running. Uh, this whole, uh, infrastructure is known as PKI or public key infrastructure. And, uh, one of the things I had to do is for our research groups, uh, website lab edu is I had to install this certificate that was generated from case. And so this is actually installed on the web server. So um, so I had to go through that same process with a CSR and so on. So what I want you to do is let's go back to the VM and let's get our hands dirty doing this. And you don't need to be root anymore. Uh. Oh. What happened? There we go. Okay. So I'm going to break out of that. I'm going to clear. And if you're still root, you could type in exit. And I'm just going to clear the screen. And I will post, um, these commands that we run through here today. It's not actually too much, but, um, just like how we can use open SSL for, uh, encryption or generating keys and doing encryption on the command line. Um, really what most people are probably more familiar with using it for, because the name is SSL, which is a precursor to TLS. Transport Layer Security is to generate certificates, view certificates, sign off on certificates. If you get pretty comfortable with OpenSSL, you can actually run. You can create some scripts that will automatically analyze certificates and the strengths of those certificates. Make sure you did a research project with students doing that. So it's pretty powerful utility. All right. So what we're going to do is we're going to do a request for a new certificate. I want to generate a new key. And I'm going to use the RSA algorithm. And 2048 is really um, is really the minimum uh, key size we should use. Remember this will be asymmetric. I'm going to pass a nodes flag to it. And I'm going to specify where I want that key out to be. And let's imagine that we're generating one for k. So I'm going to do CW crew dot key. And this is generating a certificate signing request. So our file is going to be called CW Brookshire. Okay. Certificate signed request. That's it. CSR. And if I hit enter. I'm going to get a bunch of stuff down here. So some random generation. And it's going to ask me for a country name. Okay. And you can start to type that information out. You do need to supply it. But I'm just keeping this up here in case you miss a part of that command. Um, so for the country, you can just go ahead and do us, unless you want to do Australia. You do the. Oh, um, and then go ahead and type in the state, the locality and so on. But this is going to generate. What's that? That's just a random number. Did random generation. Yeah. For generating that key using RSA. I think it kind of prints that out to make you feel good. That's doing something random. Um, but here if you type in. So if you were to generate a key using like SSH key gen, which we'll take a look at later in the semester, you'll see something similar. All right. So for the country name to us we are in Ohio. Locality Cleveland. Organization name. I'm just going to do crew organization unit SSDs. Uh, common name. Uh, I'm going to say commsec.k.edu. I'm making this up. Don't submit this certificate on request. Um, and then my email address. Um, be it be or be at B2 edu and then a password. So if I want to have some extra attributes. So like if when I send my certificate request which I type in pass optional company name enter. And at that point I should see that file I'm doing lsl str. Lighter. And there's my key. Notice again this is our private key. I only have access to it. But my CSR, anybody has access to it because I'm going to end up submitting that or I would. So if I, if you cut out that CSR request. You'll see a bunch of information in there. And what do you think. What do you see there. Basic 64 encoder. Right. Okay. We're not going to decode that though. All right. So what I want to do is I want to generate a self-signed certificate. So I'm going to use OpenSSL request new key again RSA 2048. In fact I'm going to make it easy. I'm just going to hit up up up I got dash nodes. I got my key out. CW route key. Um, but now instead of the out CW route CSR, I'm going to say, uh, I'm going to generate a certificate using X509. How many days I want it to be valid? I'm going to do 365 and I want to output that cert. So I'm going to dash out CW route 60. So it's going to generate that cert. Wait hold on. Should be asked this. No hold on I shouldn't be asked that. Let me see. Request new key RSA dash nodes dash key out X509 365. Mm. That's not right. That's not right. I got boo boo there. Um. New key. Open SSL. Oh. Uh. This should create the self-signed. Yeah, this should create the self-signed certificate. I think this is going to do it all in one. Uh, so I'm just going to go through that again. Um, CW crew CD's, common name comp.edu email address. be@b.edu. And then now if I take a look at it, uh, now I got that certificate. Okay. And if I wanted to verify this certificate I can use OpenSSL to verify I could pass a verbose flag to it. It's going to ask what the CA file is and the CA file is cw CRT. So it's going to this is what your browser essentially does is it grabs it CA file the certificate file that it gets presented to it and then it verifies the Certificate. But since this is self-signed, they're both the same. And if I hit enter, it tells me. Okay. After all that, it's okay. Right. You can verify information about certificate two using open SSL. And I think this word will probably stop because we're running out of time. But if I just pass in a text, I pass a no out. No out. And then what? My CSR is CSR. It will tell me all the information. Remember that was a base64 encoded file. But I can see the signature on there. I can see the subject and all that information using that OpenSSL command. Okay. All right. On a quiz or exam I'm not going to ask you to generate verbatim this type of command, but I want you to at least be aware of what you can do with the OpenSSL. We use it to do encryption with symmetric and asymmetric keys. We generate keys using it. We generate a certificate request with it. We verify certificates with it and much more. So. Well, I want you to think in your head as you walk out today is when there's a vulnerability in OpenSSL. And there was one recently that got patched. What kind of implications it has. Because if we're using this for generating keys and signing, encrypting and signing and all these other things, we need to make sure that's pretty solid. So all right, I'll post the slides from today. I'll post example from Java today. I'll do it this afternoon. So if you want to take a look at it you can take a look at it there. And I'll post these commands as well so you can see those. I'll see you all Thursday. Hello Mr.. I have a question. Yeah. Your password on your VM is not some sensitive password you're using anywhere else, Know why. Because you showed the Etsy shadow patch, and I may or may not have been able to write it down. Okay. If something gets sensitive and you use it elsewhere, I don't want to crack it as a joke. No. Yeah. No. No, it's not, it's not. Yeah, because I don't know. It seems like a fun thing to try and have an i7 get up there. Okay. I would not take offense to it. Okay. I appreciate you asking, though. Hi. How are you doing? Good. Thank you. How's it going? Yeah. Okay. I don't usually wear one. And when I try to run it, it's just like, scream. But, like, I don't know how to fix this. Did you try doing a hard reboot on it? Okay. That's good. Sorry. No. You're fine. Oh my gosh. No problem. All right. So but let me ask you this. Why would you feel that way? Have you done this before? I don't know. Yeah. It's okay. That's why we're here. We're learning. So this is good. This is exciting. So anytime you run into that, you might disagree. Okay. Okay. Thank you. Yep. All right. So, who are you? Oh, you know why? Um. I bet. See you there. You need to do it right here. I'm sorry. You're still using the password? Oh, yeah. I won't post a full code, though. So you can always compare it to. So if it's still not working. For. You.
